<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>《图解设计模式》学习笔记 - zhouer&#39;s blog</title>
    <meta property="og:title" content="《图解设计模式》学习笔记 - zhouer&#39;s blog">
    

    <link rel="icon" type="image/ico" sizes="32x32" href="/favicon-32.ico">
<link rel="icon" type="image/ico" sizes="16x16" href="/favicon-16.ico">
<link rel="icon" type="image/ico" sizes="48x48" href="/favicon-48.ico">

    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="相关代码。
[&amp;hellip;] 用于在数据集合中按照顺序遍历集合。
[&amp;hellip;] 类适配器模式：使用继承类和继承要求实现方法的接口，重写接口方法时调用父类方法实现包装。
[&amp;hellip;] 对象适配器模式：利用被包装类的具体实现的方法调用实现包装，即在适配器中创建一个被包装类的实例。
[&amp;hellip;] 在父类中定义处理流程的框架，在子类中实现具体处理
[&amp;hellip;] 单例。 &amp;hellip;">
      <meta property="og:description" content="相关代码。
[&amp;hellip;] 用于在数据集合中按照顺序遍历集合。
[&amp;hellip;] 类适配器模式：使用继承类和继承要求实现方法的接口，重写接口方法时调用父类方法实现包装。
[&amp;hellip;] 对象适配器模式：利用被包装类的具体实现的方法调用实现包装，即在适配器中创建一个被包装类的实例。
[&amp;hellip;] 在父类中定义处理流程的框架，在子类中实现具体处理
[&amp;hellip;] 单例。 &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423175824810.png">
    
    

    

    
    

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="cn">
    <header class="masthead">
      <h1><a href="/">zhouer&#39;s blog</a></h1>

<p class="tagline">阅读、学习、写作自留地</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" hidden/>
  <label id="menu-label" for="menu-check" class="unselectable" hidden>
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/">Home</a></li>
  
  <li><a href="/about/">About</a></li>
  
  <li><a href="/categories/">Categories</a></li>
  
  <li><a href="/tags/">Tags</a></li>
  
  <li><a href="/index.xml">Subscribe</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>《图解设计模式》学习笔记</h1>

<h3>zhouer
  /  2022-04-26</h3>
<hr>


      </header>





<p>相关<a href="https://github.com/ZHOUxunkan/design-patterns">代码</a>。</p>
<h2 id="iterator-模式">Iterator 模式</h2>
<p>用于在数据集合中按照顺序遍历集合。</p>
<ul>
<li>next() 返回当前元素，并指向下一个元素；</li>
<li>hasNext() 确认接下来是否可以调用 next 方法。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423175824810.png" alt="image-20220423175824810" style="zoom:80%;" />
<h2 id="adapter-模式">Adapter 模式</h2>
<ul>
<li>target 负责定义所需要的方法；</li>
<li>client 负责使用 target 所定义的方法，即具体的业务实现；</li>
<li>adaptee 被适配的一方，即提供方法具体实现的一方；</li>
<li>adapter 使用 adaptee 已有的功能满足 target 的需求，适配器本体。</li>
</ul>
<p>类适配器模式：使用继承类和继承要求实现方法的接口，重写接口方法时调用父类方法实现包装。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423175913707.png" alt="image-20220423175913707" style="zoom: 80%;" />
<p>对象适配器模式：利用被包装类的具体实现的方法调用实现包装，即在适配器中创建一个被包装类的实例。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423175928970.png" alt="image-20220423175928970" style="zoom: 80%;" />
<h2 id="template-method-模式">Template Method 模式</h2>
<p>在父类中定义处理流程的框架，在子类中实现具体处理</p>
<ul>
<li>AbstractClass 负责声明在模板方法中所使用到的抽象方法和实现模板方法；</li>
<li>ConcreteClass 负责实现 AbstractClass 定义的抽象方法。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423180005880.png" alt="image-20220423180005880" style="zoom: 80%;" />
<h2 id="factory-method-模式">Factory Method 模式</h2>
<ul>
<li>Product 属于框架的一部分，是一个抽象类，定义了工厂生产出的实例所持有的接口，具体的实现由子类决定；</li>
<li>Creator 属于框架的一部分，是负责生产产品的抽象类，<strong>不使用 new 关键字来生产实例，而是调用生产实例的专门方法（即在 create 方法中对 createProduct 抽象方法的调用），这样可以防止父类与其他具体类的实现</strong>。</li>
<li>ConcreteProduct Product 的具体实现；</li>
<li>ConcreteCreator Creator 的具体实现。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423180041030.png" alt="image-20220423180041030" style="zoom: 50%;" />
<h2 id="singleton-模式">Singleton 模式</h2>
<p>单例。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423180115824.png" alt="image-20220423180115824" style="zoom: 67%;" />
<h2 id="prototype-模式">Prototype 模式</h2>
<p>根据实例来生成新实例。</p>
<ul>
<li>Prototype 负责定义用于复制现有实例来生成新实例的方法，构成 client 与 prototype 具体实现类的中介，达成解耦；</li>
<li>ConcretePrototype 负责实现复制现有实例并生成新实例的方法，即实现 createClone 方法；</li>
<li>Client 负责使用复制实例的方法生成新的实例，采用注册中心的形式，调用 Prototype 的 createClone 方法实现复制。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220423180146891.png" alt="image-20220423180146891" style="zoom: 50%;" />
<h2 id="builder-模式">Builder 模式</h2>
<ul>
<li>Builder 负责定义用于生成实例的接口；</li>
<li>ConcreteBuilder Builder 的具体实现，还定义了处理结果的返回方法；</li>
<li>Direct 负责使用 Builder 的接口来生成实例，不直接依赖于 ConcreteBuilder，只与 Builder 发生关系；</li>
<li>Client Builder 模式的使用者，调用Direct 后传入ConcreteBuilder 的实例实现 build 过程。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424095255061.png" alt="image-20220424095255061" style="zoom: 50%;" />
<h2 id="abstract-factory-模式">Abstract Factory 模式</h2>
<ul>
<li>AbstractProduct 负责定义 AbstractFactory 所生产的抽象零件和产品的接口；</li>
<li>AbstractFactory 负责定义用于生成抽象产品的接口；</li>
<li>Client 调用AbstractProduct 和 AbstractFactory 的接口来工作；</li>
<li>ConcreteProduct 负责实现 AbstractProduct 的接口；</li>
<li>ConcreteFactory 负责实现 AbstractFactory 的接口；</li>
</ul>
<p>易于增加具体的工厂，难以增加新的零件。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424104201204.png" alt="image-20220424104201204" style="zoom: 50%;" />
<h2 id="bridge-模式">Bridge 模式</h2>
<p>将类的功能层次结构和实现层次结构连接，即对接口添加功能的需求和对接口规定 API 不同实现的需求。Bridge 模式将两者区隔开并创建一个连接通道。</p>
<ul>
<li>Abstraction 位于<strong>功能层次结构</strong>的最上层，在其中维持一个 Implementor 实现类，调用其方法；</li>
<li>RefinedAbstraction 继承 Abstraction，添加新功能；</li>
<li>Implementor 位于<strong>实现层次结构</strong>的最上层，作为接口规定 API ，并被 Abstraction 调用；</li>
<li>ConcreteImplementor 实现 Implementor 接口。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424112822832.png" alt="image-20220424112822832" style="zoom:67%;" />
<p>继承是强关联，委托是弱关联（方法调用）。</p>
<h2 id="strategy-模式">Strategy 模式</h2>
<p>整体替换。</p>
<ul>
<li>Strategy 负责提供策略所必须要的接口；</li>
<li>ConcreteStrategy 具体实现策略；</li>
<li>Context 负责使用 Strategy。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424121451058.png" alt="image-20220424121451058" style="zoom: 50%;" />
<h2 id="composite-模式">Composite 模式</h2>
<p>使容器和内容具有一致性，创造出递归结构。</p>
<ul>
<li>Leaf 表示内容，类似叶子节点，其中不能加入其他角色；</li>
<li>Composite 容器，可放入容器与内容；</li>
<li>Component Leaf 和 Composite 的父类，统一两者；</li>
<li>Client 调用 Composite 模式者。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424144622823.png" alt="image-20220424144622823" style="zoom: 50%;" />
<h2 id="decorator-模式">Decorator 模式</h2>
<p>嵌套装饰。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424151650643.png" alt="image-20220424151650643" style="zoom:50%;" />
<ul>
<li>Component 增加功能时的核心角色，所有成员的最高父类；</li>
<li>ConcreteComponent Component 的具体实现类；</li>
<li>Decorator 装饰物，和 Component 具有相同的接口，内部保存了被装饰的对象；</li>
<li>ConcreteDecorator Decorator 的具体实现，也可被装饰。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220424151615062.png" alt="image-20220424151615062" style="zoom:50%;" />
<p>重点在于装饰物与被装饰物具有一致性（具有相同的接口），装饰物包裹被装饰物后依旧可以调用接口，采用委托的形式实现了功能的叠加。</p>
<h2 id="visitor-模式">Visitor 模式</h2>
<p>在 Visitor 中规定 visit 方法（可重载以拓展功能），在被访问对象中定义 accept 方法，传入 Visitor 实例调用其 visit 方法，达到将处理都集中在 Visitor 中的目的。</p>
<ul>
<li>Visitor 负责对数据结构中的每个具体元素声明一个用于访问的方法；</li>
<li>ConcreteVisitor 实现 Visitor 规定的接口，在 visit 方法进行中其内部状态可以变化，即是一种类似递归的状态；</li>
<li>Element 访问对象的接口，声明 accept 方法；</li>
<li>ConcreteElement 负责实现 Element 的接口；</li>
<li>ObjectStructure 负责处理 Element 的集合。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220425113425853.png" alt="image-20220425113425853" style="zoom:50%;" />
<h2 id="chain-of-responsibility-模式">Chain of Responsibility 模式</h2>
<p>将多个对象组成一条职责链，按照顺序一个一个地找出到底应该谁来负责处理。</p>
<ul>
<li>Handler 定义了处理者的接口，维持了下一个处理者；</li>
<li>ConcreteHandler 各种 Handler 的具体实现，组成处理链条；</li>
<li>Client 向第一个 ConcreteHandler 发送请求的角色。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220425121448804.png" alt="image-20220425121448804" style="zoom:50%;" />
<h2 id="facade-模式">Facade 模式</h2>
<ul>
<li>Facade 代表构成系统的许多其他角色的“简单窗口”，对内作为协调者实现方法，对外暴露接口以供调用；</li>
<li>被调用者 只实现自己的功能模块，与其他模块不相交；</li>
<li>Client Facade的调用者。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427112001587.png" alt="image-20220427112001587" style="zoom:50%;" />
<h2 id="mediator-模式">Mediator 模式</h2>
<ul>
<li><del>Mediator 负责定义与 Colleague 之间进行通讯和做出决定的接口；</del></li>
<li><del>ConcreteMediator 实现接口；</del></li>
<li><del>Colleague 定义与 Mediator 之间进行通讯和做出决定的接口；</del></li>
<li><del>ConcreteColleague 实现接口。</del></li>
</ul>
<hr>
<p>由 Mediator 创建和管理所有的 Colleague 组件，具体来说就是就是在每个 Colleague 中注册 Mediator，在Mediator 中注册每一个 Colleague ，保持两者之间的通讯，在此基础上，实现 Colleague 向 Mediator 报告每一次状态变化，根据变化 Mediator 调用 Colleague 统一的接口实现不同的需求（该接口由各个 Colleague 实现类具体实现）。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427121204114.png" alt="image-20220427121204114" style="zoom: 40%;" />
<h2 id="observer-模式">Observer 模式</h2>
<ul>
<li>Subject 定义了注册观察者和删除观察者的方法，声明通知观察者的接口（调用不同观察者的不同具体实现）；</li>
<li>ConcreteSubject 自身发生变化时执行通知观察者的行为；</li>
<li>Observer 接受通知，声明 update 方法；</li>
<li>ConcreteObserver 具体实现不同功能的 update 方法， update 方法会在被通知后调用，获取观察对象的最新状态。</li>
</ul>
<p>具体的说，Observer 只是提供了对观察对象的处理方法（该方法需要传入观察对象或需要的属性），在每次观察对象状态变化时，由观察对象自身在已注册的Observer 中遍历调用这一处理方法；这一角度看来 Observer 可以被看做只是数据处理方法的提供者，实现了数据自身与其的解耦。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427131455984.png" alt="image-20220427131455984" style="zoom:50%;" />
<h2 id="memento-模式">Memento 模式</h2>
<p>在保存和恢复实例时保护对象的封装性。</p>
<ul>
<li>Originator 在保存自己的最新状态时生成 Memento。当把以前保存的Memento传递给 Originator 时会将自己恢复成Memento的状态；</li>
<li>Memento 保存 Originator 的内部信息作为快照，并且不会向外暴露接口，只有同个包内的 Originator 才能访问；可以采用宽接口和窄接口两种API模式，即对 get 方法的权限修饰词采用默认或 public。</li>
<li>CareTaker 在需要保存 Originator 的状态时，会调用Originator 的方法生成 Memento 实例，并一直保存一个Memento ，只能调用 Memento 的窄接口，不能访问 Memento 的其他内部信息。</li>
</ul>
<p>就是隔离快照和使用者的一种模式。（非常草率）</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427141622252.png" alt="image-20220427141622252" style="zoom: 67%;" />
<h2 id="state-模式">State 模式</h2>
<p>将复杂的 if-else 状态判断拆分成一个个表示状态的 State 类，在Context 中直接调用 State 实例的方法，这些方法在不同的 State 中有不同的实现，State 实现类中也有切换状态的方法，即切换成不同的 ConcreteState 。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427145643424.png" alt="image-20220427145643424" style="zoom: 50%;" />
<h2 id="flyweight-模式">Flyweight 模式</h2>
<p>通过共享实例减少 new 实例。</p>
<ul>
<li>Flyweight  被轻量化的类，只在需要的时候被 FlyweightFactory 创建一个实例然后被复用；</li>
<li>FlyweightFactory 工厂类，通常是单例的，在需要时生产并保存一个 Flyweight 实例；</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427165741159.png" alt="image-20220427165741159" style="zoom:50%;" />
<h2 id="proxy-模式">Proxy 模式</h2>
<p>代理模式。</p>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427173555345.png" alt="image-20220427173555345" style="zoom: 67%;" />
<h2 id="command-模式">Command 模式</h2>
<ul>
<li>Command 定义命令的接口；</li>
<li>ConcreteCommand 实现接口；</li>
<li>Receiver 执行命令时的对象，接收命令；</li>
<li>Invoker 调用 Command 的接口方法 excute。</li>
</ul>
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427181549634.png" alt="image-20220427181549634" style="zoom:50%;" />
<img src="https://zxk-pic.oss-cn-beijing.aliyuncs.com/md/image-20220427181612756.png" alt="image-20220427181612756" style="zoom:50%;" />



  <footer>
  
  

  
  <hr>
  <div class="copyright">© <a href="https://ZHOUxunkan.github.io">Xunkan Zhou</a> 2022 | <a href="https://github.com/ZHOUxunkan">Github</a></div>
  
  </footer>
  </article>
  
  </body>
</html>


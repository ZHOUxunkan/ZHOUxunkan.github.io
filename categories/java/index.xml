<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on zhouer&#39;s blog</title>
    <link>/categories/java/</link>
    <description>Recent content in Java on zhouer&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《圖解設計模式》學習筆記</title>
      <link>/cn/2022/04/26/%E5%9C%96%E8%A7%A3%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>/cn/2022/04/26/%E5%9C%96%E8%A7%A3%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</guid>
      <description>相關代碼。
Iterator 模式 用於在數據集合中按照順序遍歷集合。
 next() 返回當前元素，並指向下一個元素； hasNext() 確認接下來是否可以調用 next 方法。  Adapter 模式  target 負責定義所需要的方法； client 負責使用 target 所定義的方法，即具體的業務實現； adaptee 被適配的一方，即提供方法具體實現的一方； adapter 使用 adaptee 已有的功能滿足 target 的需求，適配器本體。  類適配器模式：使用繼承類和繼承要求實現方法的接口，重寫接口方法時調用父類方法實現包裝。
對象適配器模式：利用被包裝類的具體實現的方法調用實現包裝，即在適配器中創建一個被包裝類的實例。
Template Method 模式 在父類中定義處理流程的框架，在子類中實現具體處理
 AbstractClass 負責聲明在模板方法中所使用到的抽象方法和實現模板方法； ConcreteClass 負責實現 AbstractClass 定義的抽象方法。  Factory Method 模式  Product 屬於框架的一部分，是一個抽象類，定義了工廠生產出的實例所持有的接口，具體的實現由子類決定； Creator 屬於框架的一部分，是負責生產產品的抽象類，不使用 new 關鍵字來生產實例，而是調用生產實例的專門方法（即在 create 方法中對 createProduct 抽象方法的調用），這樣可以防止父類與其他具體類的實現。 ConcreteProduct Product 的具體實現； ConcreteCreator Creator 的具體實現。  Singleton 模式 單例。
Prototype 模式 根據實例來生成新實例。</description>
    </item>
    
  </channel>
</rss>
